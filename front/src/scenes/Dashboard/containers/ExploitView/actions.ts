import { AxiosError, AxiosResponse } from "axios";
import { Action, AnyAction, Dispatch } from "redux";
import { ThunkAction, ThunkDispatch } from "redux-thunk";
import { msgError, msgSuccess } from "../../../../utils/notifications";
import rollbar from "../../../../utils/rollbar";
import translate from "../../../../utils/translations/translate";
import Xhr from "../../../../utils/xhr";
import * as actionTypes from "./actionTypes";

export interface IActionStructure {
  /* tslint:disable-next-line:no-any
   * Disabling this rule is necessary because the payload
   * type may differ between actions
   */
  payload: any;
  type: string;
}

type ThunkDispatcher = Dispatch<Action> & ThunkDispatch<{}, {}, AnyAction>;
/* tslint:disable-next-line:no-any
 * Disabling this rule is necessary because the args
 * of an async action may differ
 */
type ThunkActionStructure = ((...args: any[]) => ThunkAction<void, {}, {}, AnyAction>);

export const loadExploit: ThunkActionStructure =
  (findingId: string): ThunkAction<void, {}, {}, Action> =>
    (dispatch: ThunkDispatcher): void => {
      let gQry: string;
      gQry = `{
      finding(identifier: "${findingId}") {
        exploit
      }
    }`;
      new Xhr().request(gQry, "An error occurred getting exploit")
        .then((response: AxiosResponse) => {
          const { data } = response.data;

          dispatch({
            payload: {
              code: data.finding.exploit,
            },
            type: actionTypes.LOAD_EXPLOIT,
          });
        })
        .catch((error: AxiosError) => {
          if (error.response !== undefined) {
            const { errors } = error.response.data;

            msgError(translate.t("proj_alerts.error_textsad"));
            rollbar.error(error.message, errors);
          }
        });
    };

export const editExploit: (() => IActionStructure) =
  (): IActionStructure => ({
    payload: undefined,
    type: actionTypes.EDIT_EXPLOIT,
  });

export const updateExploit: ThunkActionStructure =
  (
    findingId: string, projectName: string,
  ): ThunkAction<void, {}, {}, Action> => (dispatch: ThunkDispatcher): void => {
    let gQry: string;
    gQry = `mutation {
      updateEvidence (
        id: "7",
        findingId: "${findingId}",
        projectName: "${projectName}") {
        success
        finding {
          exploit
        }
      }
    }`;
    new Xhr().upload(gQry, "#evidence7", "An error occurred updating exploit")
      .then((response: AxiosResponse) => {
        const { data } = response.data;
        if (data.updateEvidence.success) {
          dispatch({
            payload: { code: data.updateEvidence.finding.exploit },
            type: actionTypes.LOAD_EXPLOIT,
          });
          msgSuccess(
            translate.t("proj_alerts.file_updated"),
            translate.t("search_findings.tab_users.title_success"),
          );
        } else {
          msgError(translate.t("proj_alerts.error_textsad"));
        }
      })
      .catch((error: AxiosError) => {
        if (error.response !== undefined) {
          const { errors } = error.response.data;

          switch (errors[0].message) {
            case "File exceeds the size limits":
              msgError(translate.t("proj_alerts.file_size"));
              break;
            case "Extension not allowed":
              msgError(translate.t("proj_alerts.file_type_wrong"));
              break;
            default:
              msgError(translate.t("proj_alerts.no_file_update"));
              rollbar.error(error.message, errors);
          }
        }
      });
  };
