""" GraphQL Entity for Vulnerability  """
# pylint: disable=F0401
# pylint: disable=no-self-use
# pylint: disable=super-init-not-called
# pylint: disable=relative-beyond-top-level
# Disabling this rule is necessary for importing modules beyond the top level
# directory.
from datetime import datetime
import cgi

import yaml
from magic import Magic
from graphene import String, ObjectType, Boolean, Mutation, List
from graphene.types.generic import GenericScalar
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from django.core.files.uploadedfile import (
    InMemoryUploadedFile, TemporaryUploadedFile
)

from app.domain.vulnerability import (
    is_range, is_secuence, ungroup_specific, add_vuln_to_dynamo
)
from .. import util
from ..exceptions import (
    InvalidRange, InvalidSchema, InvalidFileSize, InvalidFileType
)
from ..dao import integrates_dao
from ..decorators import require_login, require_role, require_finding_access_gql

FILE_PATH = '/usr/src/app/app/entity/'


class Vulnerability(ObjectType):  # noqa pylint: disable=too-many-instance-attributes
    """Vulnerability Class."""

    id = String()  # noqa pylint: disable=invalid-name
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    current_state = String()

    def __init__(self, vuln_data):
        """Class constructor."""
        self.access = False
        self.id = ''  # noqa pylint: disable=invalid-name

        finding_id = str(vuln_data.get('finding_id'))

        if vuln_data.get('vuln_type') == 'old':
            self.where = vuln_data.get('where')
        else:
            self.id = vuln_data.get('UUID')
            self.vuln_type = vuln_data.get('vuln_type')
            self.where = vuln_data.get('where')
            self.specific = vuln_data.get('specific')
            self.finding_id = finding_id
            all_states = vuln_data.get('historic_state')
            self.historic_state = all_states
            self.current_state = all_states[len(all_states) - 1].get('state')

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments(object):
        """Arguments of the class."""

        id = String(required=True)  # noqa pylint: disable=invalid-name
        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access_gql
    def mutate(self, info, **kwargs):
        """Delete vulnerability from database."""
        del info

        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        project = integrates_dao.get_finding_project(finding_id)
        release_date_dynamo = integrates_dao.get_finding_attributes_dynamo(
            finding_id,
            ['releaseDate'])
        release_date = release_date_dynamo.get('releaseDate', '')
        success = False

        vulnerability = integrates_dao.get_vulnerability_dynamo(finding_id, uuid=uuid)
        if vulnerability and vulnerability[0].get('historic_state'):
            all_states = vulnerability[0].get('historic_state')
            current_state = all_states[len(all_states) - 1].get('state')
            if current_state == 'open' and not release_date:
                was_deleted = integrates_dao.delete_vulnerability_dynamo(uuid, finding_id)
                success = was_deleted
            else:
                success = False
        else:
            success = False
        ret = DeleteVulnerability(success=success)
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        return ret


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments(object):
        """Arguments of the class."""

        finding_id = String(required=True)
    success = Boolean()

    @require_login
    @require_role(['analyst', 'admin'])
    @require_finding_access_gql
    def mutate(self, info, **kwargs):
        """Process file input."""
        finding_id = kwargs.get('finding_id')
        project = integrates_dao.get_finding_project(finding_id)
        file_input = info.context.FILES.get('document', None)
        mime = Magic(mime=True)
        if isinstance(file_input, TemporaryUploadedFile):
            mime_type = mime.from_file(file_input.temporary_file_path())
        elif isinstance(file_input, InMemoryUploadedFile):
            mime_type = mime.from_buffer(file_input.file.getvalue())
        else:
            mime_type = ''
        mib = 1048576
        if (file_input and
                mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
            if file_input.size < 1 * mib:
                try:
                    success = process_file(file_input, finding_id, info)
                except (InvalidRange, InvalidSchema):
                    raise
            else:
                success = False
                raise InvalidFileSize()
        else:
            success = False
            raise InvalidFileType()
        ret = UploadFile(success=success)
        if success:
            update_last_vuln_date(finding_id)
        else:
            # We only want to update last vuln date, if the uploadFile function
            # works correctly, if not, the code should not do anything.
            pass
        util.invalidate_cache(finding_id)
        util.invalidate_cache(project)
        return ret


def process_file(file_input, finding_id, info):
    """Process a file."""
    success = False
    file_content = cgi.escape(file_input.read())
    file_input.seek(0)
    vulnerabilities = yaml.safe_load(file_content)
    file_url = '/tmp/vulnerabilities.yaml'
    stream = file(file_url, 'w')
    yaml.safe_dump(vulnerabilities, stream)
    try:
        is_valid_schema = validate_file_schema(file_url, info)
    except InvalidSchema:
        raise
    if is_valid_schema:
        try:
            success = map_vulns_to_dynamo(vulnerabilities, finding_id, info)
        except InvalidRange:
            raise
    else:
        success = False
    return success


def validate_file_schema(file_url, info):
    """Validate if a file has the correct schema."""
    core = Core(source_file=file_url, schema_files=[FILE_PATH + 'schema.yaml'])
    is_valid = False
    try:
        core.validate(raise_exception=True)
        is_valid = True
    except (CoreError, SchemaError):
        util.cloudwatch_log(
            info.context,
            'Error: An error occurred validating vulnerabilities file')
        is_valid = False
        raise InvalidSchema()
    return is_valid


def map_vulns_to_dynamo(vulnerabilities, finding_id, info):
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            try:
                inputs_added = list(
                    map(lambda x, vuln=vuln: add_vulnerability(x, vuln, finding_id, info),
                        file_vuln))
            except InvalidRange:
                raise
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def add_vulnerability(item, vuln_type, finding_id, info):
    """Add vulnerability to dynamo."""
    where_haders = {}
    where_haders['inputs'] = {'where': 'url', 'specific': 'field'}
    where_haders['lines'] = {'where': 'path', 'specific': 'line'}
    where_haders['ports'] = {'where': 'host', 'specific': 'port'}
    response = False
    for vuln, vuln_info in where_haders.items():
        if vuln_type == vuln:
            where = item.get(vuln_info.get('where'))
            specific = item.get(vuln_info.get('specific'))
            data = {}
            data['where'] = where
            data['state'] = item.get('state')
            if (vuln == 'lines' and
                    (is_range(specific) or is_secuence(specific))):
                try:
                    specific_values = ungroup_specific(specific)
                except InvalidRange:
                    raise
                else:
                    vuln_added = \
                        [add_vuln_to_dynamo(data, i, vuln,
                                            finding_id, info)
                         for i in specific_values]
                    response = all(vuln_added)
            else:
                response = add_vuln_to_dynamo(data, specific, vuln_type, finding_id, info)
    return response


def update_last_vuln_date(finding_id):
    inc = 0
    has_new_open_vulns = False
    vulnerabilities = integrates_dao.get_vulnerabilities_dynamo(finding_id)
    today_date = str(datetime.today().strftime('%Y-%m-%d %H:%M:%S'))
    while inc < len(vulnerabilities) and has_new_open_vulns is False:
        vuln_historics = vulnerabilities[inc].get('historic_state')
        current_state = vuln_historics[len(vuln_historics) - 1].get('state')
        current_date = vuln_historics[len(vuln_historics) - 1].get('date')
        if current_state == 'open' and \
           current_date.split(' ')[0] == today_date.split(' ')[0]:
            primary_keys = ['finding_id', str(finding_id)]
            description = {'lastVulnerability': today_date}
            integrates_dao.add_multiple_attributes_dynamo('FI_findings', primary_keys, description)
            has_new_open_vulns = True
        else:
            inc += 1
    success = has_new_open_vulns
    return success
