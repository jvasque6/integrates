""" GraphQL Entity for Vulnerability  """
# pylint: disable=F0401
# pylint: disable=relative-beyond-top-level
# Disabling this rule is necessary for importing modules beyond the top level
# directory.

import yaml
import pytz
import uuid
import rollbar
from .. import util
from graphene import String, ObjectType, Boolean, Mutation, List
from ..services import has_access_to_finding
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from datetime import datetime
from ..dao import integrates_dao
from graphene.types.generic import GenericScalar

FILE_PATH = "/usr/src/app/app/entity/"


class Vulnerability(ObjectType):
    """Vulnerability Class."""

    id = String()
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    access = Boolean()

    def __init__(self, info, vuln_data):
        """Class constructor."""
        self.access = False
        self.id = ""

        finding_id = str(vuln_data.get('finding_id'))
        if (info.context.session['role'] in ['analyst', 'admin'] \
            and has_access_to_finding(
                info.context.session['access'],
                finding_id,
                info.context.session['role'])):
            self.access = True
            self.id = vuln_data.get('UUID')
            self.vuln_type = vuln_data.get('vuln_type')
            self.where = vuln_data.get('where')
            self.specific = vuln_data.get('specific')
            self.finding_id = finding_id
            self.historic_state = vuln_data.get('historic_state')
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to retrieve finding info without permission')

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_access(self, info):
        """Resolve access attribute."""
        del info
        return self.access

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments(object):
        """Arguments of the class."""

        finding_id = String(required=True)
    access = Boolean()
    success = Boolean()

    @classmethod
    def mutate(self, args, info, **kwargs):
        """Process file input."""
        del args
        self.success = False
        finding_id = kwargs.get('finding_id')
        if (info.context.session['role'] in ['analyst', 'customer', 'admin'] \
            and has_access_to_finding(
                info.context.session['access'],
                finding_id,
                info.context.session['role'])):
            self.access = True
            file_input = info.context.FILES.get("file", None)
            if file_input:
                vulnerabilities = yaml.load(file_input.read())
                stream = file("/tmp/vulnerabilities.yaml", 'w')
                yaml.dump(vulnerabilities, stream)
                c = Core(source_file="/tmp/vulnerabilities.yaml", schema_files=[FILE_PATH + "schema.yaml"])
                try:
                    c.validate(raise_exception=True)
                    where = ["inputs", "lines", "ports"]
                    for vuln in where:
                        file_vuln = vulnerabilities.get(vuln)
                        if file_vuln:
                            inputs_added = list(
                                map(lambda x, vuln=vuln: add_to_dynamo(x, vuln, finding_id, info),
                                    file_vuln))
                            self.success = all(inputs_added)
                except (CoreError, SchemaError):
                    rollbar.report_message(
                        'Error: An error occurred adding vulnerabilities',
                        'error',
                        info.context)
                    self.success = False
        else:
            self.access = False
        return UploadFile(access=self.access, success=self.success)


def add_to_dynamo(item, vuln_type, finding_id, info):
    """Add vulnerability to dynamo."""
    historic_state = []
    tzn = pytz.timezone('America/Bogota')
    where_haders = {}
    where_haders["inputs"] = {"where": "url", "specific": "field"}
    where_haders["lines"] = {"where": "path", "specific": "line"}
    where_haders["ports"] = {"where": "ip", "specific": "port"}
    response = False
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    for vuln, vuln_info in where_haders.items():
        if vuln_type == vuln:
            where = item.get(vuln_info.get("where"))
            specific = item.get(vuln_info.get("specific"))
            vuln_exits = integrates_dao.get_vulnerability_dynamo(finding_id, vuln, where, specific)
            if vuln_exits:
                response = update_state(vuln_exits, item, finding_id, current_day)
            else:
                data = {}
                data["vuln_type"] = vuln
                data["where"] = where
                data["specific"] = specific
                data["finding_id"] = finding_id
                data["UUID"] = str(uuid.uuid4())
                if item.get('state'):
                    historic_state.append({'date': current_day, 'state': item.get('state')})
                    data["historic_state"] = historic_state
                    response = integrates_dao.add_vulnerability_dynamo("FI_vulnerabilities", data)
                else:
                    util.cloudwatch_log(
                        info.context,
                        'Security: Attempted to add vulnerability without state')
    return response


def update_state(vuln_exits, item, finding_id, current_day):
    """Update vulnerability state."""
    historic_state = vuln_exits[0].get('historic_state')
    last_state = historic_state[len(historic_state) - 1]
    response = False
    if last_state.get('state') != item.get('state'):
        historic_state = []
        current_state = {'date': current_day, 'state': item.get('state')}
        historic_state.append(current_state)
        response = integrates_dao.update_state_dynamo(
            finding_id,
            vuln_exits[0].get("UUID"),
            "historic_state",
            historic_state,
            vuln_exits)
    else:
        response = True
    return response
