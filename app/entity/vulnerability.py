""" GraphQL Entity for Vulnerability  """
# pylint: disable=F0401
# pylint: disable=relative-beyond-top-level
# Disabling this rule is necessary for importing modules beyond the top level
# directory.

import yaml
import pytz
import uuid
import rollbar
from .. import util
from magic import Magic
from graphene import String, ObjectType, Boolean, Mutation, List
from django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile
from ..services import has_access_to_finding
from pykwalify.core import Core
from pykwalify.errors import CoreError, SchemaError
from datetime import datetime
from ..dao import integrates_dao
from ..api.drive import DriveAPI
from graphene.types.generic import GenericScalar

FILE_PATH = "/usr/src/app/app/entity/"


class Vulnerability(ObjectType):
    """Vulnerability Class."""

    id = String()
    finding_id = String()
    vuln_type = String()
    where = String()
    specific = String()
    historic_state = List(GenericScalar)
    access = Boolean()
    current_state = String()

    def __init__(self, info, vuln_data):
        """Class constructor."""
        self.access = False
        self.id = ""

        finding_id = str(vuln_data.get('finding_id'))
        if (info.context.session['role'] in ['analyst', 'admin', 'customer'] \
            and has_access_to_finding(
                info.context.session['access'],
                finding_id,
                info.context.session['role'])):
            self.access = True
            if vuln_data.get('vuln_type') == 'old':
                self.where = vuln_data.get('where')
            else:
                self.id = vuln_data.get('UUID')
                self.vuln_type = vuln_data.get('vuln_type')
                self.where = vuln_data.get('where')
                self.specific = vuln_data.get('specific')
                self.finding_id = finding_id
                all_states = vuln_data.get('historic_state')
                self.historic_state = all_states
                self.current_state = all_states[len(all_states) - 1].get('state')
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to retrieve finding info without permission')

    def resolve_id(self, info):
        """Resolve id attribute."""
        del info
        return self.id

    def resolve_access(self, info):
        """Resolve access attribute."""
        del info
        return self.access

    def resolve_finding_id(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.finding_id

    def resolve_vuln_type(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.vuln_type

    def resolve_where(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.where

    def resolve_specific(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.specific

    def resolve_historic_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.historic_state

    def resolve_current_state(self, info):
        """Resolve vulnerabilities attribute."""
        del info
        return self.current_state


class DeleteVulnerability(Mutation):
    """Delete a vulnerability."""

    class Arguments(object):
        """Arguments of the class."""

        id = String(required=True)
        finding_id = String(required=True)
    access = Boolean()
    success = Boolean()

    @classmethod
    def mutate(self, args, info, **kwargs):
        """Delete vulnerability from database."""
        del args
        finding_id = kwargs.get('finding_id')
        uuid = kwargs.get('id')
        self.success = False
        if (info.context.session['role'] in ['analyst', 'admin'] \
            and has_access_to_finding(
                info.context.session['access'],
                finding_id,
                info.context.session['role'])):
            self.access = True
            vulnerability = integrates_dao.get_vulnerability_dynamo(finding_id, uuid=uuid)
            if vulnerability and vulnerability[0].get('historic_state'):
                all_states = vulnerability[0].get('historic_state')
                current_state = all_states[len(all_states) - 1].get('state')
                if current_state == 'open':
                    was_deleted = integrates_dao.delete_vulnerability_dynamo(uuid, finding_id)
                    self.success = was_deleted
                else:
                    self.success = False
            else:
                self.success = False
        else:
            self.access = False
        return DeleteVulnerability(access=self.access, success=self.success)


class UploadFile(Mutation):
    """Upload a file with the vulnerabilities."""

    class Arguments(object):
        """Arguments of the class."""

        finding_id = String(required=True)
    access = Boolean()
    success = Boolean()

    @classmethod
    def mutate(self, args, info, **kwargs):
        """Process file input."""
        del args
        finding_id = kwargs.get('finding_id')
        if (info.context.session['role'] in ['analyst', 'admin'] \
            and has_access_to_finding(
                info.context.session['access'],
                finding_id,
                info.context.session['role'])):
            self.access = True
            file_input = info.context.FILES.get('file', None)
            mime = Magic(mime=True)
            if isinstance(file_input, TemporaryUploadedFile):
                mime_type = mime.from_file(file_input.temporary_file_path())
            elif isinstance(file_input, InMemoryUploadedFile):
                mime_type = mime.from_buffer(file_input.file.getvalue())
            else:
                mime_type = ''
            if (file_input and
                    mime_type in ['text/x-yaml', 'text/plain', 'text/html']):
                self.success = process_file(file_input, finding_id, info)
            else:
                self.success = False
        else:
            self.access = False
        return UploadFile(access=self.access, success=self.success)


def process_file(file_input, finding_id, info):
    """Process a file."""
    success = False
    vulnerabilities = yaml.load(file_input.read())
    file_url = '/tmp/vulnerabilities.yaml'
    stream = file(file_url, 'w')
    yaml.dump(vulnerabilities, stream)
    if validate_file_schema(file_url, info):
        success = mapping_vulnerabilities_to_dynamo(vulnerabilities, finding_id, info)
    else:
        success = False
    return success


def validate_file_schema(file_url, info):
    """Validate if a file has the correct schema."""
    c = Core(source_file=file_url, schema_files=[FILE_PATH + 'schema.yaml'])
    is_valid = False
    try:
        c.validate(raise_exception=True)
        is_valid = True
    except (CoreError, SchemaError):
        rollbar.report_message(
            'Error: An error occurred validating vulnerabilities file',
            'error',
            info.context)
        is_valid = False
    return is_valid


def mapping_vulnerabilities_to_dynamo(vulnerabilities, finding_id, info):
    """Map vulnerabilities and send it to dynamo."""
    where = ['inputs', 'lines', 'ports']
    vulns_added = []
    for vuln in where:
        file_vuln = vulnerabilities.get(vuln)
        if file_vuln:
            inputs_added = list(
                map(lambda x, vuln=vuln: add_to_dynamo(x, vuln, finding_id, info),
                    file_vuln))
            vulns_added.append(all(inputs_added))
        else:
            pass
            # If a file does not have a type of vulnerabilities,
            # this does not represent an error or an exceptional condition.
    if vulns_added:
        success = all(vulns_added)
    else:
        success = False
    return success


def validate_formstack_file(file_id, finding_id, info):
    """Check if a file from forstack is valid."""
    drive_api = DriveAPI()
    vuln_file = drive_api.download(file_id)
    success = False
    if util.assert_file_mime(vuln_file,
                             ['text/x-yaml', 'text/plain', 'text/html']):
        with open(vuln_file, 'r') as file_obj:
            success = process_file(file_obj, finding_id, info)
    else:
        success = False
    return success


def add_to_dynamo(item, vuln_type, finding_id, info):
    """Add vulnerability to dynamo."""
    historic_state = []
    tzn = pytz.timezone('America/Bogota')
    where_haders = {}
    where_haders['inputs'] = {'where': 'url', 'specific': 'field'}
    where_haders['lines'] = {'where': 'path', 'specific': 'line'}
    where_haders['ports'] = {'where': 'ip', 'specific': 'port'}
    response = False
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    for vuln, vuln_info in where_haders.items():
        if vuln_type == vuln:
            where = item.get(vuln_info.get('where'))
            specific = item.get(vuln_info.get('specific'))
            vuln_exits = integrates_dao.get_vulnerability_dynamo(
                finding_id, vuln_type=vuln, where=where, specific=specific)
            if vuln_exits:
                response = update_state(vuln_exits, item, finding_id, current_day)
            else:
                data = {}
                data['vuln_type'] = vuln
                data['where'] = where
                data['specific'] = specific
                data['finding_id'] = finding_id
                data['UUID'] = str(uuid.uuid4())
                if item.get('state'):
                    historic_state.append({'date': current_day, 'state': item.get('state')})
                    data['historic_state'] = historic_state
                    response = integrates_dao.add_vulnerability_dynamo('FI_vulnerabilities', data)
                else:
                    util.cloudwatch_log(
                        info.context,
                        'Security: Attempted to add vulnerability without state')
    return response


def update_state(vuln_exits, item, finding_id, current_day):
    """Update vulnerability state."""
    historic_state = vuln_exits[0].get('historic_state')
    last_state = historic_state[len(historic_state) - 1]
    response = False
    if last_state.get('state') != item.get('state'):
        historic_state = []
        current_state = {'date': current_day, 'state': item.get('state')}
        historic_state.append(current_state)
        response = integrates_dao.update_state_dynamo(
            finding_id,
            vuln_exits[0].get('UUID'),
            'historic_state',
            historic_state,
            vuln_exits)
    else:
        response = True
    return response
