"""Domain functions for vulnerabilities."""
# pylint: disable=relative-beyond-top-level
# Disabling this rule is necessary for importing modules beyond the top level
# directory.
from datetime import datetime
from operator import itemgetter
import itertools
import uuid
import pytz
from ..dao import integrates_dao
from ..exceptions import InvalidRange
from .. import util


def ungroup_specific(specific):
    """Ungroup specific value."""
    values = specific.split(',')
    specific_values = []
    for val in values:
        if is_range(val):
            range_list = range_to_list(val)
            specific_values.extend(range_list)
        else:
            specific_values.append(val)
    return specific_values


def is_range(specific):
    """Validate if a specific field has range value."""
    return '-' in specific


def is_secuence(specific):
    """Validate if a specific field has secuence value."""
    return ',' in specific


def range_to_list(range_value):
    """Convert a range value into list."""
    limits = range_value.split('-')
    if int(limits[1]) > int(limits[0]):
        init_val = int(limits[0])
        end_val = int(limits[1]) + 1
    else:
        raise InvalidRange()
    specific_values = map(str, range(init_val, end_val))
    return specific_values


def sort_vulnerabilities(item):
    """Sort a vulnerability by its where field."""
    sorted_item = sorted(item, key=itemgetter('where'))
    return sorted_item


def group_specific(specific):
    """Group vulnerabilities by its specific field."""
    sorted_specific = sort_vulnerabilities(specific)
    lines = []
    for key, group in itertools.groupby(sorted_specific, key=lambda x: x['where']):
        specific_grouped = list(map(get_specific, list(group)))
        specific_grouped.sort()
        dictlines = {'where': key, 'specific': get_ranges(specific_grouped)}
        lines.append(dictlines)
    return lines


def get_specific(value):
    """Get specific value."""
    return int(value.get('specific'))


def as_range(iterable):
    """Convert range into string."""
    my_list = list(iterable)
    range_value = ''
    if len(my_list) > 1:
        range_value = '{0}-{1}'.format(my_list[0], my_list[-1])
    else:
        range_value = '{0}'.format(my_list[0])
    return range_value


def get_ranges(numberlist):
    """Transform list into ranges."""
    range_str = ','.join(as_range(g) for _, g in itertools.groupby(
        numberlist,
        key=lambda n,
        c=itertools.count(): n - next(c))
    )
    return range_str


def update_vuln_state(info, vulnerability, item, finding_id, current_day):
    """Update vulnerability state."""
    historic_state = vulnerability[0].get('historic_state')
    last_state = historic_state[len(historic_state) - 1]
    response = False
    if last_state.get('state') != item.get('state'):
        historic_state = []
        user_data = util.get_jwt_content(info.context)
        analyst = user_data['user_email']
        current_state = {
            'date': current_day,
            'state': item.get('state'),
            'analyst': analyst}
        historic_state.append(current_state)
        response = integrates_dao.update_state_dynamo(
            finding_id,
            vulnerability[0].get('UUID'),
            'historic_state',
            historic_state,
            vulnerability)
    else:
        response = True
    return response


def add_vuln_to_dynamo(item, specific, vuln, finding_id, info):
    """Add vulnerability to dynamo."""
    historic_state = []
    where = item.get('where')
    vulnerability = integrates_dao.get_vulnerability_dynamo(
        finding_id, vuln_type=vuln, where=where, specific=specific)
    response = False
    tzn = pytz.timezone('America/Bogota')
    current_day = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
    user_data = util.get_jwt_content(info.context)
    email = user_data['user_email']
    if vulnerability:
        response = update_vuln_state(info, vulnerability, item, finding_id, current_day)
    else:
        data = {}
        data['vuln_type'] = vuln
        data['where'] = where
        data['specific'] = specific
        data['finding_id'] = finding_id
        data['UUID'] = str(uuid.uuid4())
        if item.get('state'):
            historic_state.append({
                'date': current_day,
                'state': item.get('state'),
                'analyst': email})
            data['historic_state'] = historic_state
            response = integrates_dao.add_vulnerability_dynamo('FI_vulnerabilities', data)
        else:
            util.cloudwatch_log(
                info.context,
                'Security: Attempted to add vulnerability without state')
    return response


def update_vulnerabilities_date(analyst, finding_id):
    """Update vulnerabilities date when a verification is required."""
    vulnerabilities = integrates_dao.get_vulnerabilities_dynamo(finding_id)
    for vuln in vulnerabilities:
        all_states = vuln.get('historic_state')
        current_state = all_states[len(all_states) - 1]
        tzn = pytz.timezone('America/Bogota')
        last_date = datetime.strptime(
            current_state.get('date').split(" ")[0],
            '%Y-%m-%d'
        )
        last_date = last_date.replace(tzinfo=tzn).date()
        current_date = datetime.now(tz=tzn).date()
        if last_date != current_date:
            historic_state = []
            current_time = datetime.now(tz=tzn).today().strftime('%Y-%m-%d %H:%M:%S')
            last_state = {
                'date': current_time,
                'state': current_state.get('state'),
                'analyst': analyst}
            historic_state.append(last_state)
            integrates_dao.update_state_dynamo(
                finding_id,
                vuln.get('UUID'),
                'historic_state',
                historic_state,
                [vuln])
        else:
            # A finding that change the same day should not be updated
            pass
