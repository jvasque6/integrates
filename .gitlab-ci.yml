image: registry.gitlab.com/fluidsignal/serves:builder

.vault_vars:
  variables:
    VAULT_ADDR: "https://${VAULT_S3_BUCKET}.com"
    VAULT_HOST: "${VAULT_S3_BUCKET}.com"
    VAULT_PORT: 443
    VAULTENV_SECRETS_FILE: "${CI_PROJECT_DIR}/env.vars"
    ENV: DEV
    ENV_NAME: development
    ROLE_ID: "${INTEGRATES_DEV_ROLE_ID}"
    SECRET_ID: "${INTEGRATES_DEV_SECRET_ID}"

.jfrog_vars: &jfrog_vars
  variables:
    CI_REGISTRY: "${JFROG_REPO}"
    CI_REGISTRY_USER: "${INTEGRATES_JFROG_USER}"
    CI_REGISTRY_PASSWORD: "${INTEGRATES_JFROG_PASS}"
    CI_REGISTRY_EMAIL: "${INTEGRATES_JFROG_EMAIL}"
    CI_REGISTRY_IMAGE: "${JFROG_REPO}/integrates"

.vault_setup: &vault_setup |-
  if [ "${CI_COMMIT_REF_NAME}" == "master" ]; then
    export ENV=PROD
    export ENV_NAME=production
    export ROLE_ID="${INTEGRATES_PROD_ROLE_ID}"
    export SECRET_ID="${INTEGRATES_PROD_SECRET_ID}"
  fi
  sed -i 's#/env#/'"${ENV_NAME}"'#g' "${VAULTENV_SECRETS_FILE}"
  export VAULT_TOKEN=$(vault write \
    -field=token auth/approle/login \
    role_id="${ROLE_ID}" \
    secret_id="${SECRET_ID}")

.vault_login: &vault_login
  extends: .vault_vars
  before_script:
    - *vault_setup

.kaniko_config: &kaniko_config
  <<: *jfrog_vars
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  before_script:
    - echo '{"auths":{"'"${CI_REGISTRY}"'":{"username":"'"${CI_REGISTRY_USER}"'","password":"'"${CI_REGISTRY_PASSWORD}"'"}}}'
        > /kaniko/.docker/config.json

.kaniko_vault_config: &kaniko_vault_config
  extends: .vault_vars
  <<: *kaniko_config
  before_script:
    - wget -O vault.zip https://releases.hashicorp.com/vault/0.11.6/vault_0.11.6_linux_amd64.zip;
        unzip vault.zip;
        mv vault /busybox/
    - *vault_setup
    - export FI_DRIVE_AUTHORIZATION=$(vault read -field=drive_authorization secret/integrates/${ENV_NAME})
    - export FI_DRIVE_AUTHORIZATION_CLIENT=$(vault read -field=drive_authorization_client secret/integrates/${ENV_NAME})
    - export FI_DOCUMENTROOT=$(vault read -field=documentroot secret/integrates/${ENV_NAME})
    - export FI_SSL_KEY=$(vault read -field=ssl_key secret/integrates/${ENV_NAME})
    - export FI_SSL_CERT=$(vault read -field=ssl_cert secret/integrates/${ENV_NAME})
    - echo '{"auths":{"'"${CI_REGISTRY}"'":{"username":"'"${CI_REGISTRY_USER}"'","password":"'"${CI_REGISTRY_PASSWORD}"'"}}}'
        > /kaniko/.docker/config.json

stages:
  - deps
  - pre-test
  - build
  - review
  - mr-check
  - deploy
  - post-deploy
  - coverage

build:
  stage: deps
  <<: *kaniko_config
  script:
    - mkdir deploy/containers/deps/front
    - mkdir deploy/containers/deps/assets
    - cp -a front/package.json deploy/containers/deps/front/
    - cp -a app/assets/package.json deploy/containers/deps/assets
    - /kaniko/executor
        --cleanup
        --context "${CI_PROJECT_DIR}/deploy/containers/deps/"
        --dockerfile "${CI_PROJECT_DIR}/deploy/containers/deps/Dockerfile"
        --destination "${CI_REGISTRY_IMAGE}:deps"
        --snapshotMode time
  retry: 1
  only:
    - schedules

.terraform-test:
  stage: pre-test
  <<: *vault_login
  script:
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
        deploy/
    - cd deploy
    - terraform init
    - vaultenv $(which terraform) plan
  except:
    - master

gulp-compiler:
  stage: pre-test
  image: fluid-docker.jfrog.io/integrates:deps
  script:
    - cp -a /root/front/node_modules front/
    - cd front
    - npm install --unsafe-perm
    - node_modules/.bin/gulp
  artifacts:
    paths:
      - app/assets/dashboard/*
    expire_in: 1h
  retry: 1
  except:
    - master

commitlint:
  stage: pre-test
  image: starefossen/ruby-node:2-10
  script:
    - npm install --unsafe-perm
    - ./ci-scripts/commitlint-checks.sh
  except:
    - master

react-testing:
  stage: pre-test
  image: fluid-docker.jfrog.io/integrates:deps
  script:
    - cp -a /root/front/node_modules front/
    - cd front
    - npm install --unsafe-perm
    - node_modules/.bin/tslint -p tsconfig.json -t verbose
    - npm test
    - node_modules/.bin/tsc -p tsconfig.json
  artifacts:
    name: "coverage_lcov_${CI_COMMIT_REF_NAME}_${CI_COMMIT_SHA:0:8}"
    paths:
      - front/coverage.lcov
    expire_in: 1 week
  only:
    - /^.*$/
    - merge_requests

js-linter:
  stage: pre-test
  image: fluid-docker.jfrog.io/integrates:deps
  script:
    - cp -a /root/front/node_modules front/
    - cd front
    - npm install --unsafe-perm
    - node_modules/.bin/eslint app/assets/app/.
  retry: 1
  except:
    - master

prospector-testing:
  stage: pre-test
  image: fluid-docker.jfrog.io/integrates:deps
  <<: *vault_login
  script:
    - vaultenv -- prospector -F -s veryhigh -u django -p app/ -i node_modules || true
    - vaultenv -- prospector -F -s high -u django -p app/ -i node_modules
    - vaultenv -- prospector -F -s veryhigh -u django fluidintegrates/
  except:
    - master

unit-testing:
  stage: pre-test
  image: fluid-docker.jfrog.io/integrates:deps
  <<: *vault_login
  script:
    - cp -a $PWD /usr/src/app_src
    - cd /usr/src/app_src
    - service redis-server start
    - vaultenv -- pytest --ds=fluidintegrates.settings --verbose --exitfirst
        --cov=fluidintegrates --cov=app --cov-report term
        --cov-report html:build/coverage/html
        --cov-report xml:build/coverage/results.xml
        --cov-report annotate:build/coverage/annotate
        --basetemp=build/test
        --junitxml=build/test/results.xml
        app/tests.py
    - cp -a build/coverage/results.xml "${CI_PROJECT_DIR}/coverage.xml"
  artifacts:
    name: "coverage_xml_${CI_COMMIT_REF_NAME}_${CI_COMMIT_SHA:0:8}"
    paths:
      - coverage.xml
    expire_in: 1 week
  only:
    - /^.*$/
    - merge_requests

asserts-code-test:
  stage: pre-test
  image: fluidattacks/asserts
  script:
    - asserts exploit-code.py
  except:
    - master

.terraform-deploy:
  stage: build
  <<: *vault_login
  script:
    - pip install boto3==1.8.9
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
        deploy/terraform.tfstate || export NEW_DEPLOY=true
    - cd deploy
    - export TF_VAR_dynamo_access_key="$(vault read
        -field=aws_dynamodb_access_key secret/integrates/production)"
    - export TF_VAR_dynamo_secret_key="$(vault read
        -field=aws_dynamodb_secret_key secret/integrates/production)"
    - terraform init
    - terraform apply -auto-approve
    - if [ -n "${NEW_DEPLOY}" ];
        then python migratedynamo.py
        $FI_AWS_DYNAMODB_ACCESS_KEY
        $FI_AWS_DYNAMODB_SECRET_KEY
        $OLD_FI_AWS_DYNAMODB_ACCESS_KEY
        $OLD_FI_AWS_DYNAMODB_SECRET_KEY;
        fi
  after_script:
    - aws s3 cp
        deploy/terraform.tfstate
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
  only:
    - master

build-integrates:
  stage: build
  dependencies:
    - gulp-compiler
  <<: *kaniko_vault_config
  script:
    - mv app/assets/dashboard deploy/containers/common/vars
    - mv deploy/containers/common/vars deploy/containers/integrates/
    - MINUTES=$(( 
        ($(date +%d | sed 's/^0//') -1) * 1440 +
        $(date +%H | sed 's/^0//') * 60 + 
        $(date +%M | sed 's/^0//') 
      ))
    - FI_VERSION="$(date +%y.%m.)${MINUTES}"
    - /kaniko/executor
        --build-arg CI_API_V4_URL="${CI_API_V4_URL}"
        --build-arg CI_COMMIT_REF_NAME="${CI_COMMIT_REF_NAME}"
        --build-arg CI_PROJECT_ID="${CI_PROJECT_ID}"
        --build-arg CI_REPOSITORY_URL="${CI_REPOSITORY_URL}"
        --build-arg DOCUMENTROOT="${FI_DOCUMENTROOT}"
        --build-arg DRIVE_AUTHORIZATION="${FI_DRIVE_AUTHORIZATION}"
        --build-arg DRIVE_AUTHORIZATION_CLIENT="${FI_DRIVE_AUTHORIZATION_CLIENT}"
        --build-arg ENV_NAME="${ENV_NAME}"
        --build-arg SSL_CERT="${FI_SSL_CERT}"
        --build-arg SSL_KEY="${FI_SSL_KEY}"
        --build-arg VERSION="${FI_VERSION}"
        --cleanup
        --context "${CI_PROJECT_DIR}/deploy/containers/integrates/"
        --dockerfile "${CI_PROJECT_DIR}/deploy/containers/integrates/Dockerfile"
        --destination "${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_NAME}"
        --snapshotMode time
  retry: 1

build-bot:
  stage: build
  dependencies: []
  <<: *kaniko_vault_config
  script:
    - mv deploy/containers/common/vars deploy/containers/bot/
    - /kaniko/executor
        --build-arg CI_API_V4_URL="${CI_API_V4_URL}"
        --build-arg CI_COMMIT_REF_NAME="${CI_COMMIT_REF_NAME}"
        --build-arg CI_PROJECT_ID="${CI_PROJECT_ID}"
        --build-arg CI_REPOSITORY_URL="${CI_REPOSITORY_URL}"
        --build-arg DOCUMENTROOT="${FI_DOCUMENTROOT}"
        --build-arg DRIVE_AUTHORIZATION="${FI_DRIVE_AUTHORIZATION}"
        --build-arg DRIVE_AUTHORIZATION_CLIENT="${FI_DRIVE_AUTHORIZATION_CLIENT}"
        --build-arg ENV_NAME="${ENV_NAME}"
        --build-arg SSL_CERT="${FI_SSL_CERT}"
        --build-arg SSL_KEY="${FI_SSL_KEY}"
        --cleanup
        --context "${CI_PROJECT_DIR}/deploy/containers/bot/"
        --dockerfile "${CI_PROJECT_DIR}/deploy/containers/bot/Dockerfile"
        --destination "${CI_REGISTRY_IMAGE}-bot:${CI_COMMIT_REF_NAME}"
        --snapshotMode time
  retry: 1

driver-testing:
  stage: post-deploy
  image: fluid-docker.jfrog.io/integrates:deps
  dependencies: []
  <<: *vault_login
  script:
    - curl -Lo geckodriver.tar.gz https://github.com/mozilla/geckodriver/releases/download/v0.24.0/geckodriver-v0.24.0-linux64.tar.gz
    - tar xzf geckodriver.tar.gz -C /usr/local/bin
    - rm geckodriver.tar.gz
    - apt-get update
    - apt-get install --no-install-recommends -y firefox-esr
    - cp -a $PWD /usr/src/app_src
    - cd /usr/src/app_src
    - mkdir -p screenshots
    - vaultenv -- pytest
        --ds=fluidintegrates.settings
        --verbose
        --exitfirst
        --basetemp=build/test
        app/ephimeral_tests.py
    - cp -a screenshots /builds/fluidattacks/integrates/
  retry: 1
  artifacts:
    name: "regression_${CI_COMMIT_REF_NAME}_${CI_COMMIT_SHA:0:8}"
    paths:
      - screenshots/

review-integrates:
  stage: review
  dependencies: []
  <<: *vault_login
  script:
    - vaultenv review-apps/cluster-config.sh
  retry: 1
  environment:
    name: "review/$CI_COMMIT_REF_SLUG"
    url: "https://$CI_COMMIT_REF_SLUG.$CI_PROJECT_NAME.env.fluidattacks.com/integrates"
    on_stop: stop-review
  except:
    - master

stop-review:
  stage: review
  dependencies: []
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  variables:
    GIT_STRATEGY: none
  script:
    - kubectl config set-context
        "$(kubectl config current-context)"
        --namespace="${CI_PROJECT_NAME}"
    - kubectl delete deployment "review-${CI_COMMIT_REF_SLUG}"
    - kubectl delete service "service-${CI_COMMIT_REF_SLUG}"
    - kubectl delete ingress "review-${CI_COMMIT_REF_SLUG}"
  retry: 1
  when: manual
  except:
    - master

asserts-review:
  stage: post-deploy
  image: fluid-docker.jfrog.io/fluid:integrates
  dependencies: []
  variables:
    APP: "integrates"
    BRANCH: "${CI_COMMIT_REF_NAME}"
    FA_STRICT: "true"
    ORG: "fluid"
    PASS: "${INTEGRATES_JFROG_PASS}"
    STAGE: "review"
    USER: "${INTEGRATES_JFROG_USER}"
  script:
    - mkdir /code
    - cp -a * /code/
    - /entrypoint.sh
  retry: 1
  except:
    - master

mr-test:
  stage: mr-check
  dependencies: []
  variables:
    GIT_STRATEGY: clone
  script:
    ./ci-scripts/check-branch.sh
  only:
    - merge_request3.86.193.211s

danger:
  stage: mr-check
  image: starefossen/ruby-node:2-10
  dependencies: []
  variables:
    DANGER_GITLAB_API_TOKEN: ${DANGER_TOKEN}
    DANGER_GITLAB_HOST: "gitlab.com"
    DANGER_GITLAB_API_BASE_URL: "https://gitlab.com/api/v4"
  before_script:
    - export CI_MERGE_REQUEST_ID=$(git ls-remote -q origin merge-requests\*\head
      | grep ${CI_COMMIT_SHA}
      | sed 's/.*refs\/merge-requests\/\([0-9]*\)\/head/\1/g')
    - npm install --unsafe-perm
    - bundle install
  script:
    - bundle exec danger --verbose --fail-on-errors=true
  only:
    - merge_requests

deploy-k8s:
  stage: deploy
  dependencies: []
  environment:
    name: "production"
    url: "https://fluidattacks.com/integrates"
  <<: *vault_login
  script:
    - kubectl config set-context "$(kubectl config current-context)"
        --namespace serves
    - if ! kubectl get secret jfrog-reg; then
        echo "Creating secret to access Gitlab Registry...";
        kubectl create secret docker-registry jfrog-reg
          --docker-server="fluid-docker.jfrog.io" --docker-username="$JFROG_USER"
          --docker-password="$JFROG_PASS" --docker-email="$JFROG_EMAIL";
      fi
    - sed -i 's/$VAULT_HOST/'"$(echo -n $VAULT_HOST | base64)"'/;
        s/$VAULT_TOKEN/'"$(echo -n $VAULT_TOKEN | base64)"'/;
        s/$DATE/'"$(date)"'/g'
        integrates-k8s.yaml
    - kubectl apply -f integrates-k8s.yaml
    - kubectl rollout status deploy/integrates --timeout=5m ||
        { kubectl rollout undo deploy/integrates && exit 1; }
    - kubectl rollout status deploy/integrates-bot --timeout=5m ||
        { kubectl rollout undo deploy/integrates-bot && exit 1; }
    - curl https://api.rollbar.com/api/1/deploy/
        -F access_token=$ROLLBAR_ACCESS_TOKEN
        -F environment=$FI_ROLLBAR_ENVIRONMENT
        -F revision=$CI_COMMIT_SHA
        -F local_username="$CI_COMMIT_REF_NAME"
    - vaultenv ./new_relic_deployment.sh
  after_script:
    - rm integrates-k8s.yaml
  only:
    - master

new-version-mail:
  stage: post-deploy
  image: fluid-docker.jfrog.io/integrates:master
  dependencies: []
  <<: *vault_login
  script:
    - cd /usr/src/app
    - vaultenv -- python integrates_version.py
  only:
    - master

asserts-prod:
  stage: post-deploy
  image: fluid-docker.jfrog.io/fluid:integrates
  dependencies: []
  variables:
    APP: "integrates"
    BRANCH: "${CI_COMMIT_REF_NAME}"
    FA_STRICT: "true"
    ORG: "fluid"
    PASS: "${INTEGRATES_JFROG_PASS}"
    STAGE: "post-deploy"
    USER: "${INTEGRATES_JFROG_USER}"
  script:
    - mkdir /code
    - cp -a * /code/
    - /entrypoint.sh
  retry: 1
  only:
    - master

coverage-report:
  stage: coverage
  image: fluid-docker.jfrog.io/integrates:deps
  dependencies:
    - unit-testing
    - react-testing
  <<: *vault_login
  script:
    - vaultenv ./run_codecov.sh
  retry: 1
  only:
    - merge_requests
  except:
    - master
