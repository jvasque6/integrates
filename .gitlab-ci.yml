image: registry.gitlab.com/fluidsignal/serves:builder

variables:
  DOCKER_DRIVER: overlay2

services:
  - docker:dind


before_script:
  - echo "$CI_REGISTRY_PASSWORD" |
      docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

after_script:
  - docker logout "$CI_REGISTRY"

stages:
  - deps
  - pre-test
  - build
  - review
  - test
  - pre-deploy
  - deploy
  - post-deploy
  - cleanup

Build:
  stage: deps
  script:
    - cp front/package.json deploy/containers/deps/
    - docker build --no-cache 
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:alldeps"
        deploy/containers/deps
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:alldeps"
  retry: 2
  only:
    - schedules

terraform-test:
  stage: pre-test
  before_script:
    - echo acc_key = \"$FI_AWS_DYNAMODB_ACCESS_KEY\" >> deploy/terraform.tfvars
    - echo sec_key = \"$FI_AWS_DYNAMODB_SECRET_KEY\" >> deploy/terraform.tfvars
    - cd deploy
  script:
    - mkdir -p /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}
    - cp -a ${CI_PROJECT_DIR} /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}/src
    - terraform init
    - terraform plan
  except:
    - triggers
    - master

react-testing:
  stage: pre-test
  before_script:
    - echo "Start Unit Testing"  
  image: registry.gitlab.com/fluidsignal/integrates:alldeps
  script:
    - cd front/ && npm install 
    - tslint -p tsconfig.json -t verbose
    - npm test
    - tsc -p tsconfig.json
  after_script:
    - echo "Job finished"

js-linter:
  stage: pre-test
  before_script:
    - echo "JS Linting"
  image: registry.gitlab.com/fluidsignal/integrates:alldeps
  script:
    - eslint app/assets/app/.
  retry: 2
  except:
    - master
    - triggers

terraform-deploy:
  stage: build
  before_script:
    - pip install boto3
    - echo acc_key = \"$FI_AWS_DYNAMODB_ACCESS_KEY\" >> deploy/terraform.tfvars
    - echo sec_key = \"$FI_AWS_DYNAMODB_SECRET_KEY\" >> deploy/terraform.tfvars
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
        deploy/terraform.tfstate || export NEW_DEPLOY=true
    - cd deploy
  script:
    - terraform init
    - terraform apply -auto-approve
    - if [ -n "${NEW_DEPLOY}" ];
        then python migratedynamo.py
        $FI_AWS_DYNAMODB_ACCESS_KEY
        $FI_AWS_DYNAMODB_SECRET_KEY
        $OLD_FI_AWS_DYNAMODB_ACCESS_KEY
        $OLD_FI_AWS_DYNAMODB_SECRET_KEY;
        fi
  after_script:
    - aws s3 cp
        deploy/terraform.tfstate
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
  only:
    - master
  except:
    - triggers

build-integrates:
  stage: build
  script:
    - sh deploy/containers/integrates/build.sh
        "$CI_COMMIT_REF_NAME" "$TORUS_TOKEN_ID" "$TORUS_TOKEN_SECRET"
        "$TORUS_ORG" "$TORUS_PROJECT"
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
  retry: 2
  except:
    - triggers

build-bot:
  stage: build
  script:
    - cd deploy/containers/bot &&
      sh build.sh
      "$CI_COMMIT_REF_NAME" "$TORUS_TOKEN_ID" "$TORUS_TOKEN_SECRET"
        "$TORUS_ORG" "$TORUS_PROJECT"
    - docker push
      "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/bot:$CI_COMMIT_REF_NAME"
  retry: 2
  except:
    - triggers

review-integrates:
  stage: review
  image: lwolf/kubectl_deployer
  before_script:
    - apk update
    - apk add bash
  script:
    - ./review-apps/cluster-config.sh
  after_script:
    - echo "Job finished"
  retry: 2
  environment:
    name: "review/$CI_COMMIT_REF_SLUG"
    url: "https://$CI_COMMIT_REF_SLUG.$CI_PROJECT_NAME.$ENV_DNS"
    on_stop: stop-review
  except:
    - master
    - trigger

stop-review:
  stage: review
  image: lwolf/kubectl_deployer
  variables:
    GIT_STRATEGY: none
  before_script:
    - echo "Stopping Review Apps environment..."
  script:
    - kubectl config set-context
        "$(kubectl config current-context)"
        --namespace="$CI_PROJECT_NAME"
    - kubectl delete deployment "review-$CI_COMMIT_REF_SLUG"
    - kubectl delete service "service-$CI_COMMIT_REF_SLUG"
    - kubectl get ingress "ingress-$CI_PROJECT_NAME" -o yaml |
        sed '/host:\ '"$CI_COMMIT_REF_SLUG"'/,+5d' |
        sed '/-\ '"$CI_COMMIT_REF_SLUG"'/d' > current-ingress.yaml
    - kubectl delete ingress "ingress-$CI_PROJECT_NAME"
    - if kubectl get deployments | grep 'review-*';
        then kubectl create -f current-ingress.yaml;
        fi
  retry: 2
  after_script:
    - echo "Job finished"
  when: manual
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  except:
    - master

Asserts-Review:
  stage: test
  script:
    - echo "$JFROG_PASS" |
        docker login fluid-docker.jfrog.io -u "$JFROG_USER" --password-stdin
    - docker pull fluid-docker.jfrog.io/fluid:integrates
    - docker run
        --rm -e BRANCH="$CI_COMMIT_REF_SLUG"
        -e STAGE=review -e ORG=fluid
        -e APP=integrates -e USER="$JFROG_USER"
        -e PASS="$JFROG_PASS" -e FA_STRICT="true"
        --volume /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}/src:/code
        fluid-docker.jfrog.io/fluid:integrates
    - docker logout fluid-docker.jfrog.io
  retry: 2
  except:
    - master
    - triggers

Linting:
  stage: test
  script:
    - docker run
        -e TORUS_TOKEN_SECRET="$TORUS_TOKEN_SECRET"
        -e TORUS_TOKEN_ID="$TORUS_TOKEN_ID"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "npm install -g  n; n stable;
        cd /usr/src/app/app/assets/app/;
        result=$(/usr/src/app/app/assets/node_modules/.bin/gulp verbose | grep -c JSC_);
        if [ "$result" -gt 0 ]; then /usr/src/app/app/assets/node_modules/.bin/gulp   verbose;
        echo -e '\e[31mThere are some errors/warnings unsolved.\e[0m';exit 1;
        else echo -e '\e[32mAll Good!'; exit 0; fi;"
  retry: 2
  except:
    - master
    - triggers

Prospector:
  stage: test
  script:
    - docker run
        -e TORUS_TOKEN_SECRET="$TORUS_TOKEN_SECRET"
        -e TORUS_TOKEN_ID="$TORUS_TOKEN_ID"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "torus daemon start; sleep 5;
        torus run -- prospector -u django -p /usr/src/app/app -i node_modules"
    - docker run
        -e TORUS_TOKEN_SECRET="$TORUS_TOKEN_SECRET"
        -e TORUS_TOKEN_ID="$TORUS_TOKEN_ID"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "torus daemon start; sleep 5;
        torus run -- prospector -u django /usr/src/app/fluidintegrates"
    - docker run
        -e TORUS_TOKEN_SECRET="$TORUS_TOKEN_SECRET"
        -e TORUS_TOKEN_ID="$TORUS_TOKEN_ID"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "torus daemon start; sleep 5;
        torus run -- python -v /usr/src/app/manage.py test app.tests --no-input"
  retry: 2
  except:
    - master
    - triggers

asserts-pre-deploy:
  stage: pre-deploy
  before_script:
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
        FLUID_Serves.pem &&
        chmod 600 FLUID_Serves.pem
    - echo "$JFROG_PASS" |
        docker login fluid-docker.jfrog.io -u "$JFROG_USER" --password-stdin
    - docker pull fluid-docker.jfrog.io/fluid:integrates
  script:
    - ssh
        -o StrictHostKeyChecking=no
        -i FLUID_Serves.pem
        admin@52.1.64.44
        'sudo docker pull
        registry.gitlab.com/fluidsignal/integrates:master &&
        sudo docker run
        -d -p 8008:443 --name=test-integrates
        -e TORUS_TOKEN_SECRET='"$TORUS_TOKEN_SECRET"'
        -e TORUS_TOKEN_ID='"$TORUS_TOKEN_ID"'
        registry.gitlab.com/fluidsignal/integrates:master'
    - sleep 30
    - docker run
        --rm -e STAGE=pre-deploy -e ORG=fluid
        -e APP=integrates -e USER="$JFROG_USER"
        -e PASS="$JFROG_PASS" -e FA_STRICT="true"
        fluid-docker.jfrog.io/fluid:integrates
    - ssh
        -o StrictHostKeyChecking=no
        -i FLUID_Serves.pem
        admin@52.1.64.44
        'sudo docker stop test-integrates &&
        sudo docker rm test-integrates'
    - docker logout fluid-docker.jfrog.io
  only:
    - master

Deploy:
  stage: deploy
  before_script:
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/FLUID_Serves.pem
        FLUID_Serves.pem &&
        chmod 600 FLUID_Serves.pem
  script:
    - ssh
        -o StrictHostKeyChecking=no
        -i FLUID_Serves.pem
        admin@52.1.64.44
        'sudo docker pull
        registry.gitlab.com/fluidsignal/integrates:master &&
        sudo docker stop integrates &&
        sudo docker rm integrates &&
        sudo docker run
        -d -p 8000:443 --name=integrates
        -e TORUS_TOKEN_SECRET='"$TORUS_TOKEN_SECRET"'
        -e TORUS_TOKEN_ID='"$TORUS_TOKEN_ID"'
        registry.gitlab.com/fluidsignal/integrates:master'
    - ssh
        -o StrictHostKeyChecking=no
        -i FLUID_Serves.pem
        admin@52.1.64.44
        'sudo docker pull
        registry.gitlab.com/fluidsignal/integrates/bot:master &&
        sudo docker stop bot &&
        sudo docker rm bot &&
        sudo docker run
        -d --restart always --name=bot
        -e TORUS_TOKEN_SECRET='"$TORUS_TOKEN_SECRET"'
        -e TORUS_TOKEN_ID='"$TORUS_TOKEN_ID"'
        registry.gitlab.com/fluidsignal/integrates/bot:master'
    - curl https://api.rollbar.com/api/1/deploy/
        -F access_token=$FI_ROLLBAR_ACCESS_TOKEN
        -F environment=$FI_ROLLBAR_ENVIRONMENT
        -F revision=$CI_COMMIT_SHA
        -F local_username="$CI_COMMIT_REF_NAME"
    - docker run
        -e TORUS_TOKEN_SECRET="$TORUS_TOKEN_SECRET"
        -e TORUS_TOKEN_ID="$TORUS_TOKEN_ID"
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "torus daemon start; sleep 5;
        cd /usr/src/app/;
        torus run -- python -c 'import integrates_version; integrates_version.send_mail_version()'"
  retry: 2
  only:
    - master
  except:
    - triggers

deploy-k8s:
  stage: deploy
  before_script:
    - mkdir $HOME/.kube
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/kubeconfig
        $HOME/.kube/config
  script:
    - kubectl config set-context "$(kubectl config current-context)"
        --namespace serves
    - if ! kubectl get secret gitlab-reg; then
        echo "Creating secret to access Gitlab Registry..."
        kubectl create secret docker-registry gitlab-reg \
          --docker-server="$CI_REGISTRY" --docker-username="$DOCKER_USER" \
          --docker-password="$DOCKER_PASS" --docker-email="$DOCKER_EMAIL";
      fi
    - sed -i 's/$TORUS_TOKEN_ID/'"$(echo -n $TORUS_TOKEN_ID | base64)"'/;
        s/$TORUS_TOKEN_SECRET/'"$(echo -n $TORUS_TOKEN_SECRET | base64)"'/;
        s/$TORUS_ORG/'"$(echo -n $TORUS_ORG | base64)"'/;
        s/$TORUS_PROJECT/'"$(echo -n $TORUS_PROJECT | base64)"'/;
        s/$TORUS_ENVIRONMENT/'"$(echo -n $TORUS_ENVIRONMENT | base64)"'/;
        s/$DATE/'"$(date)"'/'
        integrates-k8s.yaml
    - kubectl apply -f integrates-k8s.yaml
  after_script:
    - rm integrates-k8s.yaml $HOME/.kube/config
  only:
    - master

asserts-prod:
  stage: post-deploy
  script:
    - echo "$JFROG_PASS" |
        docker login fluid-docker.jfrog.io -u "$JFROG_USER" --password-stdin
    - docker pull fluid-docker.jfrog.io/fluid:integrates
    - docker run
        --rm -e ORG=fluid -e STAGE=post-deploy
        -e APP=integrates -e USER="$JFROG_USER"
        -e PASS="$JFROG_PASS" -e FA_STRICT="true"
        --volume /tmp${CI_PROJECT_DIR}/${CI_COMMIT_REF_NAME}:/code
        fluid-docker.jfrog.io/fluid:integrates
    - docker logout fluid-docker.jfrog.io
  retry: 2
  only:
    - master

cleanup-code:
  stage: cleanup
  script:
    - rm -rf /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}
  when: always
