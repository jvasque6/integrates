image: registry.gitlab.com/fluidsignal/serves:builder

variables:
  DOCKER_DRIVER: overlay2

services:
  - docker:dind


before_script:
  - echo "$CI_REGISTRY_PASSWORD" |
      docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

after_script:
  - docker logout "$CI_REGISTRY" || echo 'Docker not necessary'

.variables-dev: &variables-dev
  variables:
    ENV: DEV
    ENV_FULL: development

.vault_login: &vault_login
  before_script:
    - if [ "$CI_COMMIT_REF_NAME" == "master" ]; then
        export ENV=PROD;
        export ENV_FULL=production;
        echo 'Variables updated';
      fi
    - apt-get install --no-install-recommends jq
    - pip install awscli
    - aws s3 cp
        s3://$VAULT_S3_BUCKET/vault-ca.crt
        /usr/local/share/ca-certificates/
    - update-ca-certificates
    - ROLE_ID=$(aws secretsmanager --region us-east-1
        get-secret-value --secret-id 'INTEGRATES_'"$ENV"'_ROLE_ID' |
        jq -r '.SecretString')
    - SECRET_ID=$(aws secretsmanager --region us-east-1
        get-secret-value --secret-id 'INTEGRATES_'"$ENV"'_SECRET_ID' |
        jq -r '.SecretString')
    - export VAULT_TOKEN=$(curl --request POST
        --data '{"role_id":"'"$ROLE_ID"'","secret_id":"'"$SECRET_ID"'"}'
        "https://$VAULT_S3_BUCKET.com/v1/auth/approle/login" |
        jq -r '.auth.client_token')
    - export VAULT_HOST="$VAULT_S3_BUCKET.com"
    - export VAULT_PORT=443
    - export VAULTENV_SECRETS_FILE="$CI_PROJECT_DIR/env.vars"
    - sed -i 's/env#/'"$ENV_FULL"'#/g' "$VAULTENV_SECRETS_FILE"
    - echo "$CI_REGISTRY_PASSWORD" |
        docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin ||
        echo 'Docker not necessary'

stages:
  - deps
  - pre-test
  - build
  - review
  - test
  - pre-deploy
  - deploy
  - post-deploy
  - cleanup

Build:
  stage: deps
  script:
    - cp front/package.json deploy/containers/deps/
    - docker build --no-cache 
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:alldeps"
        deploy/containers/deps
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:alldeps"
  retry: 2
  only:
    - schedules

terraform-test:
  stage: pre-test
  <<: *variables-dev
  <<: *vault_login
  script:
    - mkdir -p /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}
    - cp -a ${CI_PROJECT_DIR} /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}/src
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
        deploy/
    - cd deploy
    - terraform init
    - vaultenv $(which terraform) plan
  except:
    - triggers
    - master

gulp-compiler:
 stage: pre-test
 before_script:
   - echo "Start gulp compiler"  
 image: registry.gitlab.com/fluidsignal/integrates:alldeps
 script:
   - cd app/assets && npm install
   - cd ../../front 
   - npm install
   - gulp
 after_script:
   - echo "Job finished"
 retry: 2
 except:
   - master
   - triggers

react-testing:
  stage: pre-test
  before_script:
    - echo "Start Unit Testing"  
  image: registry.gitlab.com/fluidsignal/integrates:alldeps
  script:
    - cd front/ && npm install 
    - tslint -p tsconfig.json -t verbose
    - npm test
    - tsc -p tsconfig.json
  after_script:
    - echo "Job finished"
  except:
    - master
    - triggers

js-linter:
  stage: pre-test
  before_script:
    - echo "JS Linting"
  image: registry.gitlab.com/fluidsignal/integrates:alldeps
  script:
    - eslint app/assets/app/.
  after_script:
    - echo "Job finished"
  retry: 2
  except:
    - master
    - triggers

prospector-testing:
  stage: pre-test
  image: registry.gitlab.com/fluidsignal/integrates:alldeps
  <<: *variables-dev
  <<: *vault_login
  script:
    - vaultenv prospector.sh
  except:
    - master
    - triggers

terraform-deploy:
  stage: build
  before_script:
    - pip install boto3
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
        deploy/terraform.tfstate || export NEW_DEPLOY=true
    - cd deploy
    - export TF_VAR_dynamo_access_key="$AWS_DYNAMODB_ACCESS_KEY"
    - export TF_VAR_dynamo_secret_key="$AWS_DYNAMODB_SECRET_KEY"
  script:
    - terraform init
    - terraform apply -auto-approve
    - if [ -n "${NEW_DEPLOY}" ];
        then python migratedynamo.py
        $FI_AWS_DYNAMODB_ACCESS_KEY
        $FI_AWS_DYNAMODB_SECRET_KEY
        $OLD_FI_AWS_DYNAMODB_ACCESS_KEY
        $OLD_FI_AWS_DYNAMODB_SECRET_KEY;
        fi
  after_script:
    - aws s3 cp
        deploy/terraform.tfstate
        s3://$FS_S3_BUCKET_NAME/terraform/integrates/terraform.tfstate
  only:
    - master
  except:
    - triggers

build-integrates:
  stage: build
  <<: *variables-dev
  <<: *vault_login
  script:
    - vaultenv deploy/containers/integrates/build.sh "$CI_COMMIT_REF_NAME"
    - docker push
        "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
  retry: 2
  except:
    - triggers

build-bot:
  stage: build
  <<: *variables-dev
  <<: *vault_login
  script:
    - vaultenv deploy/containers/bot/build.sh "$CI_COMMIT_REF_NAME"
    - docker push
      "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME/bot:$CI_COMMIT_REF_NAME"
  retry: 2
  except:
    - triggers

review-integrates:
  stage: review
  <<: *variables-dev
  <<: *vault_login
  script:
    - vaultenv review-apps/cluster-config.sh
  retry: 2
  environment:
    name: "review/$CI_COMMIT_REF_SLUG"
    url: "https://$CI_COMMIT_REF_SLUG.$CI_PROJECT_NAME.$ENV_DNS"
    on_stop: stop-review
  except:
    - master
    - trigger

stop-review:
  stage: review
  variables:
    GIT_STRATEGY: none
  before_script:
    - echo "Stopping Review Apps environment..."
  script:
    - kubectl config set-context
        "$(kubectl config current-context)"
        --namespace="$CI_PROJECT_NAME"
    - kubectl delete deployment "review-$CI_COMMIT_REF_SLUG"
    - kubectl delete service "service-$CI_COMMIT_REF_SLUG"
    - kubectl get ingress "ingress-$CI_PROJECT_NAME" -o yaml |
        sed '/host:\ '"$CI_COMMIT_REF_SLUG"'/,+5d' |
        sed '/-\ '"$CI_COMMIT_REF_SLUG"'/d' > current-ingress.yaml
    - kubectl delete ingress "ingress-$CI_PROJECT_NAME"
    - if kubectl get deployments | grep 'review-*';
        then kubectl create -f current-ingress.yaml;
        fi
  retry: 2
  after_script:
    - echo "Job finished"
  when: manual
  environment:
    name: review/$CI_COMMIT_REF_SLUG
    action: stop
  except:
    - master

Asserts-Review:
  stage: test
  script:
    - echo "$JFROG_PASS" |
        docker login fluid-docker.jfrog.io -u "$JFROG_USER" --password-stdin
    - docker pull fluid-docker.jfrog.io/fluid:integrates
    - docker run
        --rm -e BRANCH="$CI_COMMIT_REF_SLUG"
        -e STAGE=review -e ORG=fluid
        -e APP=integrates -e USER="$JFROG_USER"
        -e PASS="$JFROG_PASS" -e FA_STRICT="true"
        --volume /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}/src:/code
        fluid-docker.jfrog.io/fluid:integrates
    - docker logout fluid-docker.jfrog.io
  retry: 2
  except:
    - master
    - triggers

Linting:
  stage: test
  script:
    - docker run
        -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
        /bin/bash -c "npm install -g  n; n stable;
        cd /usr/src/app/app/assets/app/;
        result=$(/usr/src/app/app/assets/node_modules/.bin/gulp verbose | grep -c JSC_);
        if [ "$result" -gt 0 ]; then /usr/src/app/app/assets/node_modules/.bin/gulp   verbose;
        echo -e '\e[31mThere are some errors/warnings unsolved.\e[0m';exit 1;
        else echo -e '\e[32mAll Good!'; exit 0; fi;"
  retry: 2
  except:
    - master
    - triggers

test-deployment:
  stage: pre-deploy
  <<: *vault_login
  script:
    - mkdir $HOME/.kube
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/kubeconfig
        $HOME/.kube/config
    - kubectl config set-context "$(kubectl config current-context)"
        --namespace serves
    - if ! kubectl get secret gitlab-reg; then
        echo "Creating secret to access Gitlab Registry..."
        kubectl create secret docker-registry gitlab-reg \
          --docker-server="$CI_REGISTRY" --docker-username="$DOCKER_USER" \
          --docker-password="$DOCKER_PASS" --docker-email="$DOCKER_EMAIL";
      fi
    - sed -i 's/$VAULT_HOST/'"$(echo -n $VAULT_HOST | base64)"'/;
        s/$VAULT_TOKEN/'"$(echo -n $VAULT_TOKEN | base64)"'/;
        s/name:\ integrates$/name:\ integrates-test/g;
        s/app:\ integrates/app:\ integrates-test/g'
        integrates-k8s.yaml
    - cat integrates-k8s.yaml | head -n 54 | kubectl apply -f -
    - kubectl rollout status deploy/integrates-test
    - kubectl get pods | egrep -o 'integrates-test[^ ]*' | tr -d '\n' | \
        xargs -0 -I {} kubectl port-forward {} 8000:80 &
    - sleep 5
    - curl http://localhost:8000 | grep --color 'FluidIntegrates'
  after_script:
    - pkill kubectl || echo 'Port Forwarding was not established'
    - kubectl delete deploy/integrates-test
    - kubectl delete svc/integrates-test
    - docker logout "$CI_REGISTRY"
  only:
    - master

deploy-k8s:
  stage: deploy
  <<: *vault_login
  script:
    - mkdir $HOME/.kube
    - aws s3 cp
        s3://$FS_S3_BUCKET_NAME/terraform/kubeconfig
        $HOME/.kube/config
    - kubectl config set-context "$(kubectl config current-context)"
        --namespace serves
    - if ! kubectl get secret gitlab-reg; then
        echo "Creating secret to access Gitlab Registry..."
        kubectl create secret docker-registry gitlab-reg \
          --docker-server="$CI_REGISTRY" --docker-username="$DOCKER_USER" \
          --docker-password="$DOCKER_PASS" --docker-email="$DOCKER_EMAIL";
      fi
    - sed -i 's/$VAULT_HOST/'"$(echo -n $VAULT_HOST | base64)"'/;
        s/$VAULT_TOKEN/'"$(echo -n $VAULT_TOKEN | base64)"'/'
        integrates-k8s.yaml
    - kubectl apply -f integrates-k8s.yaml
    - kubectl rollout status deploy/integrates -w
    - curl https://api.rollbar.com/api/1/deploy/
        -F access_token=$FI_ROLLBAR_ACCESS_TOKEN
        -F environment=$FI_ROLLBAR_ENVIRONMENT
        -F revision=$CI_COMMIT_SHA
        -F local_username="$CI_COMMIT_REF_NAME"
    - docker run
       -e VAULT_HOST="$VAULT_HOST"
       -e VAULT_TOKEN="$VAULT_TOKEN"
       -t "$CI_REGISTRY/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME:$CI_COMMIT_REF_NAME"
       /bin/bash -c "cd /usr/src/app/;
       vaultenv $(which python) integrates_version.py"
  after_script:
    - rm integrates-k8s.yaml $HOME/.kube/config
  only:
    - master

asserts-prod:
  stage: post-deploy
  script:
    - echo "$JFROG_PASS" |
        docker login fluid-docker.jfrog.io -u "$JFROG_USER" --password-stdin
    - docker pull fluid-docker.jfrog.io/fluid:integrates
    - docker run
        --rm -e ORG=fluid -e STAGE=post-deploy
        -e APP=integrates -e USER="$JFROG_USER"
        -e PASS="$JFROG_PASS" -e FA_STRICT="true"
        --volume /tmp${CI_PROJECT_DIR}/${CI_COMMIT_REF_NAME}:/code
        fluid-docker.jfrog.io/fluid:integrates
    - docker logout fluid-docker.jfrog.io
  retry: 2
  only:
    - master

cleanup-code:
  stage: cleanup
  script:
    - rm -rf /tmp${CI_PROJECT_DIR}/${CI_COMMIT_SHA}
    - rm -rf /tmp/npm*
  when: always
